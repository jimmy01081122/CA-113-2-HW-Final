1. Tiled Matrix Multiplication 技術（2x4 區塊）
為提升資料重複使用率並減少 D-cache 未命中，我們對 _matmul_core 核心相乘程式套用了區塊矩陣乘法（Tiled Matrix Multiplication）。考量 RV32IM 架構的暫存器數量有限，我們選擇2x4的區塊大小（一次計算 2 列 x 4 欄的子矩陣），以在不額外增加記憶體訪問的情況下提高快取命中率。相比原始逐元素相乘：
**空間局部性提升：**每次載入矩陣 A 的 2 個元素（連續列的同一欄位）後，立即用於計算結果矩陣中 4 個連續欄位的部分和；同樣地，載入矩陣 B 的 4 個連續元素後，用於更新 2 列的累積和。如此可使每個載入的操作數參與多次運算，大幅減少重複載入
file-f7kus5vxybvmpcjfcxpedg
file-f7kus5vxybvmpcjfcxpedg
。舉例而言，矩陣 A的某元素 A[i][k] 在原算法中每計算一個輸出元素就需重載一次，而現在透過區塊運算，載入一次 A[i][k] 就能連續用於4個不同欄位的乘積累加（等效將該元素重用4次）。矩陣 B則透過一次載入4個連續的元素（B[k][j]...B[k][j+3]）供2列運算使用，每個元素也會被重用2次。這種雙重重用顯著減少了記憶體讀取頻率。
快取命中率提高：區塊計算確保對矩陣B的訪問連續且符合快取列界限。在2x4區塊內，對B的讀取是每次取出一整行中相鄰的4個元素（例如 B[k][j0]...B[k][j0+3]），這些元素通常落在同一或相鄰快取列中。相比之下，原始三重迴圈每次內層迴圈跳躍訪問 B 的下一列元素（不同k但相同j），記憶體位址間隔大，易導致快取失效。現在透過欄位區塊，我們將對B的訪問轉為連續塊，顯著提升D-cache命中率。即使在區塊之間需跳轉B的列位址，所幸每次區塊運算時間足夠短，使先前載入的B區塊在L2快取中仍可能被命中。
**暫存器重複使用：**我們在區塊計算中使用暫存器保存子矩陣的累加結果（如上方程式碼中的 s3-s10 等）。由於2x4區塊共有8個輸出元素，使用8個暫存器即可全部存放，計算過程中無須頻繁將部分和寫回記憶體。這避免了大量中間結果的記憶體存取，加快了計算速度。同時，區塊大小選為2x4也考慮到RV32的暫存器資源：4x4區塊雖可一次覆蓋16個輸出元素，但需要16個累加暫存器，加上指標與中間變數共超過可用暫存器數，在不增加spill的前提下較難實現；2x4區塊較為平衡，能充分利用暫存器又避免溢出。若目標平台具備更多暫存器或較大快取，也可嘗試擴大至4x4或8x8區塊，以進一步減少快取未命中。
2. 迴圈展開與分支優化
我們對關鍵迴圈進行了適度的展開（unrolling），降低迴圈控制成本：
內層 k 迴圈展開：原始內層迴圈每次僅計算一個乘加，現在改為每次計算4個（對應區塊的4個欄位）。例如上述程式碼的 k_iter 部分內，對固定的 a6 = A[i0][k] 和 a7 = A[i0+1][k]，順序執行4次對應的 B[k][j0..j0+3] 乘加，再進行一次條件分支
file-f7kus5vxybvmpcjfcxpedg
file-f7kus5vxybvmpcjfcxpedg
。這樣將迴圈分支數減少了約75%（每迴圈處理4倍工作），顯著降低了分支跳轉和比較對執行管線的干擾。同時，迴圈展開有助於編譯器/處理器進行指令級平行（例如交錯執行乘法與加法），提高流水線效率。
**移除不必要的分支：**我們利用RISC-V的條件分支指令組合優化了迴圈結構。例如以 bnez（不為零則跳轉）取代原本迴圈底部的比較指令，可在每次迴圈結束時直接判斷是否繼續，減少一次比較開銷。又如將某些迴圈改用倒數計數方式，用單一暫存器遞減至0判斷結束，避免反覆與上限比較的指令。這些改動進一步降低了分支頻率。
條件合併與提前退出：在區塊迴圈外，我們採用條件判斷來區分「完整區塊」與「剩餘部分」。例如 bge s11, t1, do_tile 用於檢查剩餘欄數是否足夠一個4欄區塊，否則直接跳出主迴圈處理零頭部分，避免進入多餘的迴圈循環。類似地，i_leftover 部分在沒有奇數剩餘列時直接跳到結束。這些提前退出策略讓程式在處理邊界情況時也能減少不必要的迴圈開銷。
3. 減少冗餘的載入/存儲與地址計算
在手寫組合語言優化中，我們特別關注省略重複的記憶體訪問和精簡地址運算：
指標暫存器的運用：我們以暫存器保存矩陣起始位址及當前指標，避免每次使用乘法計算地址。例如在進入區塊計算時，先計算 A[i0] 行的起始位址存於 a2，第二行的起始位址存於 a3，而 B 矩陣當前區塊列的起始位址存於 a4。在內層迴圈中，a2 和 a3 每次遞增4（位元組）即可訪問下一個元素，無需每次重新計算 i*colsA + k 等偏移
file-f7kus5vxybvmpcjfcxpedg
；同理，a4 每次迴圈遞增 colsB*4（以a5保存）即可跳到下一列B元素
file-f7kus5vxybvmpcjfcxpedg
。這種指標累加方式用加法取代乘法，大幅減少地址計算指令數。同時也降低了重複Load運算元的頻率：原程式每次內層迴圈皆重新計算並載入 A[i][k]、B[k][j]，現在在迴圈中變為順序存取記憶體，載入和運算指令數都明顯減少。
移除多餘的記憶體訪問：透過在暫存器中累積結果，我們只在每個區塊或剩餘部分完成時才將計算結果一次性寫回記憶體。例如2x4區塊的16次乘加運算全部在暫存器中完成，最後才用8條 sw 指令批量寫入
file-f7kus5vxybvmpcjfcxpedg
。相較之下，原實作每計算一個輸出即寫一次記憶體
file-f7kus5vxybvmpcjfcxpedg
。我們也將原本的結果矩陣清零迴圈完全拿掉，因為我們並未採用反覆累加到記憶體的方式，而是直接計算出每個元素的最終值後覆蓋寫入，沒有讀取舊值的需求。這不但節省了初始化時間，還減少了Cache不必要的寫入動作。
**暫存器重複利用：**在確保正確性的前提下，我們重排了暫存器用途，讓同一暫存器存放不同階段的資料，降低Push/Pop開銷。例如我們利用函式開始時保存的參數暫存器（如 a2,a3,a4）將矩陣維度轉存到s0-s2，釋放出 a2-a4 作為指標暫存器使用；又如使用t5,t6臨時暫存器交替存放運算中的中間乘積，避免額外引入新的暫存器。這種做法在代碼中以註解形式標出，確保不與後續結果使用衝突。透過精心規劃暫存器分配，我們成功避免了在內層迴圈中使用堆疊暫存空間（spill），既降低了記憶體流量也提升了執行效能。
經以上優化，矩陣相乘的核心計算對快取的親和性明顯提高，運算指令路徑也更短更順暢。在大規模矩陣鏈相乘測試下，預期可大幅減少運行時間，降低記憶體瓶頸對效能的限制。